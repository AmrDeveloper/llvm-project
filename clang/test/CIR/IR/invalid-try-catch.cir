// RUN: cir-opt %s -verify-diagnostics -split-input-file

module {

cir.func dso_local @invalid_catch_without_all_or_type() {
  cir.scope {
    cir.try {
      cir.yield
     // expected-error @below {{'cir.try' expected attribute, 'all', or 'type' keyword}}
    } catch [invalid_keyword {
      cir.yield
    }]
  }
  cir.return
}

}

// -----

module {

cir.func dso_local @invalid_catch_rtti_type() {
  cir.scope {
    cir.try {
      cir.yield
     // expected-error @below {{expected attribute value}}
     // expected-error @below {{'cir.try' expected valid RTTI info attribute}}
    } catch [type invalid_type {
      cir.yield
    }]
  }
  cir.return
}

}

// -----

module {

cir.func dso_local @invalid_catch_empty_block() {
  cir.scope {
    cir.try {
      cir.yield
    } catch [type #cir.all {
      // expected-error @below {{'cir.try' catch region shall not be empty}}
    }]
  }
  cir.return
}

}

// -----

!s32i = !cir.int<s, 32>

module {

cir.func dso_local @invalid_catch_not_terminated() {
  %a = cir.alloca !s32i, !cir.ptr<!s32i>, ["a", init]
  cir.scope {
    cir.try {
      cir.yield
    } 
    // expected-error @below {{'cir.try' blocks are expected to be explicitly terminated}}
    catch [type #cir.all {
       %tmp_a = cir.load %a : !cir.ptr<!s32i>, !s32i
    }]
  }
  cir.return
}

}
